const $=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const n of r)if(n.type==="childList")for(const h of n.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&i(h)}).observe(document,{childList:!0,subtree:!0});function e(r){const n={};return r.integrity&&(n.integrity=r.integrity),r.referrerpolicy&&(n.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?n.credentials="include":r.crossorigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(r){if(r.ep)return;r.ep=!0;const n=e(r);fetch(r.href,n)}};$();const z=class{constructor(s=0,t=0,e=0,i=1){this.r=s,this.g=t,this.b=e,this.a=i}set(s,t,e,i){this.r=s,this.g=t,this.b=e,this.a=i}copy(s){this.r=s.r,this.g=s.g,this.b=s.b,this.a=s.a}};let R=z;R.WHITE=new z(1,1,1);R.BLACK=new z(0,0,0);R.RED=new z(1,0,0);R.GREEN=new z(0,1,0);R.BLUE=new z(0,0,1);R.YELLOW=new z(1,1,0);R.PURPLE=new z(1,0,1);R.CYAN=new z(0,1,1);class Q{constructor(t=0,e=0){this.x=t,this.y=e}}class O{static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){return t*180/Math.PI}static rescale(t,e,i,r,n){return r+(n-r)*(t-e)/(i-e)}static clamp(t,e,i){return Math.max(e,Math.min(i,t))}}class J{constructor(){this.canvas=document.getElementById("gfxCanvas"),this.canvas||alert("Unable to find gfxCanvas.");const t=this.canvas.getContext("webgl2");t||alert("Unable to initialize WebGL. Your browser or machine may not support it."),this.gl=t,this.gl.enable(this.gl.DEPTH_TEST),this.gl.depthFunc(this.gl.LESS),this.gl.enable(t.CULL_FACE),this.gl.cullFace(t.BACK),this.background=new R}resize(t,e,i){this.canvas.width=t,this.canvas.height=e,i>window.innerWidth/window.innerHeight?this.gl.viewport(0,(window.innerHeight-window.innerWidth/i)/2,window.innerWidth,window.innerWidth/i):this.gl.viewport((window.innerWidth-window.innerHeight*i)/2,0,window.innerHeight*i,window.innerHeight)}render(t,e){this.gl.clearColor(this.background.r,this.background.g,this.background.b,this.background.a),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),t.draw(e)}getNormalizedDeviceCoordinates(t,e){const i=this.gl.getParameter(this.gl.VIEWPORT);return new Q(O.clamp((t-i[0])/i[2]*2-1,-1,1),O.clamp((e-i[1])/i[3]*-2+1,-1,1))}}const c=class{static copy(s){return new c(s.x,s.y,s.z)}static inverse(s){return new c(-s.x,-s.y,-s.z)}static add(s,t){return new c(s.x+t.x,s.y+t.y,s.z+t.z)}static subtract(s,t){return new c(s.x-t.x,s.y-t.y,s.z-t.z)}static multiply(s,t){return new c(s.x*t.x,s.y*t.y,s.z*t.z)}static divide(s,t){return new c(s.x/t.x,s.y/t.y,s.z/t.z)}static dot(s,t){return s.x*t.x+s.y*t.y+s.z*t.z}static cross(s,t){return new c(s.y*t.z-s.z*t.y,s.z*t.x-s.x*t.z,s.x*t.y-s.y*t.x)}static multiplyScalar(s,t){return new c(s.x*t,s.y*t,s.z*t)}static divideScalar(s,t){return new c(s.x/t,s.y/t,s.z/t)}static normalize(s){const t=s.x*s.x+s.y*s.y+s.z*s.z;if(t<1e-8)return new c;const e=1/Math.sqrt(t);return new c(s.x*e,s.y*e,s.z*e)}static angleBetween(s,t){return s.angleBetween(t)}constructor(s=0,t=0,e=0){this.x=s,this.y=t,this.z=e}set(s,t,e){this.x=s,this.y=t,this.z=e}copy(s){this.x=s.x,this.y=s.y,this.z=s.z}clone(){return new c(this.x,this.y,this.z)}equals(s){return this.x==s.x&&this.y==s.y&&this.z==s.z}add(s){this.x+=s.x,this.y+=s.y,this.z+=s.z}subtract(s){this.x-=s.x,this.y-=s.y,this.z-=s.z}multiply(s){this.x*=s.x,this.y*=s.y,this.z*=s.z}divide(s){this.x/=s.x,this.y/=s.y,this.z/=s.z}dot(s){return this.x*s.x+this.y*s.y+this.z*s.z}cross(s){return new c(this.y*s.z-this.z*s.y,this.z*s.x-this.x*s.z,this.x*s.y-this.y*s.x)}multiplyScalar(s){this.x*=s,this.y*=s,this.z*=s}divideScalar(s){this.x/=s,this.y/=s,this.z/=s}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}normalize(){const s=this.x*this.x+this.y*this.y+this.z*this.z;if(s<1e-8)return;const t=1/Math.sqrt(s);this.x*=t,this.y*=t,this.z*=t}invert(){this.x=-this.x,this.y=-this.y,this.z=-this.z}inverse(){return new c(-this.x,-this.y,-this.z)}applyMatrix(s){const t=this.clone(),e=1/(s.mat[3]*t.x+s.mat[7]*t.y+s.mat[11]*t.z+s.mat[15]);this.x=e*(s.mat[0]*t.x+s.mat[4]*t.y+s.mat[8]*t.z+s.mat[12]),this.y=e*(s.mat[1]*t.x+s.mat[5]*t.y+s.mat[9]*t.z+s.mat[13]),this.z=e*(s.mat[2]*t.x+s.mat[6]*t.y+s.mat[10]*t.z+s.mat[14])}rotate(s){this.copy(s.rotate(this))}angleBetween(s){const t=c.normalize(this),e=c.normalize(s);return Math.acos(t.dot(e))}distanceTo(s){return Math.sqrt((this.x-s.x)*(this.x-s.x)+(this.y-s.y)*(this.y-s.y)+(this.z-s.z)*(this.z-s.z))}setPositionFromMatrix(s){this.x=s.mat[12],this.y=s.mat[13],this.z=s.mat[14]}};let o=c;o.ZERO=new c(0,0,0);o.ONE=new c(1,1,1);o.UP=new c(0,1,0);o.DOWN=new c(0,-1,0);o.LEFT=new c(-1,0,0);o.RIGHT=new c(1,0,0);o.FORWARD=new c(0,0,-1);o.BACK=new c(0,0,1);o.X_AXIS=c.RIGHT;o.Y_AXIS=c.UP;o.Z_AXIS=c.FORWARD;const A=class{static multiply(s,t){const e=new A;return e.w=s.w*t.w-s.x*t.x-s.y*t.y-s.z*t.z,e.x=s.w*t.x+s.x*t.w+s.y*t.z-s.z*t.y,e.y=s.w*t.y+s.y*t.w+s.z*t.x-s.x*t.z,e.z=s.w*t.z+s.z*t.w+s.x*t.y-s.y*t.x,e}static normalize(s){const t=s.clone();return t.normalize(),t}static inverse(s){const t=s.clone();return t.invert(),t}static makeRotationX(s){const t=new A;return t.setRotationX(s),t}static makeRotationY(s){const t=new A;return t.setRotationY(s),t}static makeRotationZ(s){const t=new A;return t.setRotationZ(s),t}static makeAxisAngle(s,t){const e=new A;return e.setAxisAngle(s,t),e}static makeEulerAngles(s,t,e){const i=new A;return i.setEulerAngles(s,t,e),i}static makeMatrix(s){const t=new A;return t.setMatrix(s),t}constructor(s=0,t=0,e=0,i=1){this.x=s,this.y=t,this.z=e,this.w=i}set(s,t,e,i){this.x=s,this.y=t,this.z=e,this.w=i}setRotationX(s){this.w=Math.cos(s/2),this.x=Math.sin(s/2),this.y=0,this.z=0}setRotationY(s){this.w=Math.cos(s/2),this.x=0,this.y=Math.sin(s/2),this.z=0}setRotationZ(s){this.w=Math.cos(s/2),this.x=0,this.y=0,this.z=Math.sin(s/2)}setAxisAngle(s,t){const e=Math.sin(t/2);this.w=Math.cos(t/2),this.x=e*s.x,this.y=e*s.y,this.z=e*s.z}setEulerAngles(s,t,e){const i=Math.cos(t/2),r=Math.sin(t/2),n=Math.cos(s/2),h=Math.sin(s/2),u=Math.cos(-e/2),l=Math.sin(-e/2);this.x=r*n*u+i*h*l,this.y=i*h*u-r*n*l,this.z=i*n*l+r*h*u,this.w=i*n*u-r*h*l}setMatrix(s){this.w=Math.sqrt(1+s.mat[0]+s.mat[5]+s.mat[10])/2,this.x=(s.mat[6]-s.mat[9])/(4*this.w),this.y=(s.mat[8]-s.mat[2])/(4*this.w),this.z=(s.mat[1]-s.mat[4])/(4*this.w)}copy(s){this.x=s.x,this.y=s.y,this.z=s.z,this.w=s.w}clone(){return new A(this.x,this.y,this.z,this.w)}multiply(s){this.copy(A.multiply(s,this))}normalize(){const s=1/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=s,this.y*=s,this.z*=s,this.w*=s}rotate(s){const t=new o(this.x,this.y,this.z),e=o.multiplyScalar(t,2*t.dot(s));e.add(o.multiplyScalar(s,this.w*this.w-t.dot(t)));const i=t.cross(s);return i.multiplyScalar(2*this.w),e.add(i),e}invert(){const s=1/(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=-s,this.y*=-s,this.z*=-s,this.w*=s}inverse(){return A.inverse(this)}getMatrix(){const s=this.w*this.w,t=this.x*this.x,e=this.y*this.y,i=this.z*this.z,r=1/(t+e+i+s),n=this.x*this.y,h=this.z*this.w,u=this.x*this.z,l=this.y*this.w,m=this.y*this.z,y=this.x*this.w;return B.fromRowMajor((t-e-i+s)*r,2*(n-h)*r,2*(u+l)*r,0,2*(n+h)*r,(-t+e-i+s)*r,2*(m-y)*r,0,2*(u-l)*r,2*(m+y)*r,-t-e+i+s,0,0,0,0,1)}};let C=A;C.IDENTITY=new A;const d=class{static multiply(s,t){const e=new d;e.mat[0]=0,e.mat[5]=0,e.mat[10]=0,e.mat[15]=0;for(let i=0;i<4;i++)for(let r=0;r<4;r++)for(let n=0;n<4;n++)e.mat[i*4+r]+=s.mat[i*4+n]*t.mat[n*4+r];return e}static copy(s){const t=new d;return t.copy(s),t}static fromRowMajor(s,t,e,i,r,n,h,u,l,m,y,a,w,x,p,b){const M=new d;return M.setRowMajor(s,t,e,i,r,n,h,u,l,m,y,a,w,x,p,b),M}static fromColumnMajor(s,t,e,i,r,n,h,u,l,m,y,a,w,x,p,b){const M=new d;return M.setColumnMajor(s,t,e,i,r,n,h,u,l,m,y,a,w,x,p,b),M}static makeTranslation(s){return d.fromRowMajor(1,0,0,s.x,0,1,0,s.y,0,0,1,s.z,0,0,0,1)}static makeRotationX(s){const t=new d;return t.makeRotationX(s),t}static makeRotationY(s){const t=new d;return t.makeRotationY(s),t}static makeRotationZ(s){const t=new d;return t.makeRotationZ(s),t}static makeRotation(s,t){const e=new d;return e.makeRotation(s,t),e}static makeScale(s){const t=new d;return t.makeScale(s),t}static makeTransform(s=o.ZERO,t=C.IDENTITY,e=o.UP){const i=new d;return i.makeTransform(s,t,e),i}static lookAt(s,t,e){const i=new d;return i.lookAt(s,t,e),i}static makePerspective(s,t,e,i){const r=e*Math.tan(s*Math.PI/360),n=r*t;return d.makeFrustum(-n,n,-r,r,e,i)}static makeFrustum(s,t,e,i,r,n){return d.fromRowMajor(2*r/(t-s),0,(t+s)/(t-s),0,0,2*r/(i-e),(i+e)/(i-e),0,0,0,-(n+r)/(n-r),-2*n*r/(n-r),0,0,-1,0)}constructor(){this.mat=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}setColumnMajor(s,t,e,i,r,n,h,u,l,m,y,a,w,x,p,b){this.mat[0]=s,this.mat[1]=t,this.mat[2]=e,this.mat[3]=i,this.mat[4]=r,this.mat[5]=n,this.mat[6]=h,this.mat[7]=u,this.mat[8]=l,this.mat[9]=m,this.mat[10]=y,this.mat[11]=a,this.mat[12]=w,this.mat[13]=x,this.mat[14]=p,this.mat[15]=b}setRowMajor(s,t,e,i,r,n,h,u,l,m,y,a,w,x,p,b){this.mat[0]=s,this.mat[1]=r,this.mat[2]=l,this.mat[3]=w,this.mat[4]=t,this.mat[5]=n,this.mat[6]=m,this.mat[7]=x,this.mat[8]=e,this.mat[9]=h,this.mat[10]=y,this.mat[11]=p,this.mat[12]=i,this.mat[13]=u,this.mat[14]=a,this.mat[15]=b}copy(s){for(let t=0;t<16;t++)this.mat[t]=s.mat[t]}element(s,t){return this.mat[t*4+s]}set(s,t,e){this.mat[e*4+t]=s}multiply(s){const t=d.multiply(s,this);this.copy(t)}makeTranslation(s){this.setRowMajor(1,0,0,s.x,0,1,0,s.y,0,0,1,s.z,0,0,0,1)}makeRotationX(s){const t=Math.cos(s),e=Math.sin(s);this.setRowMajor(1,0,0,0,0,t,-e,0,0,e,t,0,0,0,0,1)}makeRotationY(s){const t=Math.cos(s),e=Math.sin(s);this.setRowMajor(t,0,e,0,0,1,0,0,-e,0,t,0,0,0,0,1)}makeRotationZ(s){const t=Math.cos(s),e=Math.sin(s);this.setRowMajor(t,-e,0,0,e,t,0,0,0,0,1,0,0,0,0,1)}makeRotation(s,t){const e=Math.cos(t),i=Math.sin(t),r=1-e,n=s.x,h=s.y,u=s.z,l=r*n,m=r*h;this.setRowMajor(l*n+e,l*h-i*u,l*u+i*h,0,l*h+i*u,m*h+e,m*u-i*n,0,l*u-i*h,m*u+i*n,r*u*u+e,0,0,0,0,1)}makeScale(s){this.setRowMajor(s.x,0,0,0,0,s.y,0,0,0,0,s.z,0,0,0,0,1)}makePerspective(s,t,e,i){const r=e*Math.tan(s*Math.PI/360),n=r*t;this.makeFrustum(-n,n,-r,r,e,i)}makeFrustum(s,t,e,i,r,n){this.setRowMajor(2*r/(t-s),0,(t+s)/(t-s),0,0,2*r/(i-e),(i+e)/(i-e),0,0,0,-(n+r)/(n-r),-2*n*r/(n-r),0,0,-1,0)}makeTransform(s=o.ZERO,t=C.IDENTITY,e=o.ONE){this.makeTranslation(s),this.multiply(t.getMatrix()),this.multiply(d.makeScale(e))}lookAt(s,t,e=o.UP){const i=o.subtract(s,t);i.normalize();const r=o.cross(e,i);r.normalize();const n=o.cross(i,r),h=d.fromRowMajor(r.x,n.x,i.x,0,r.y,n.y,i.y,0,r.z,n.z,i.z,0,0,0,0,1),u=d.makeTranslation(s);this.copy(d.multiply(h,u))}multiplyScalar(s){for(let t=0;t<16;t++)this.mat[t]*=s}determinant(){return this.mat[3]*this.mat[6]*this.mat[9]*this.mat[12]-this.mat[2]*this.mat[7]*this.mat[9]*this.mat[12]-this.mat[3]*this.mat[5]*this.mat[10]*this.mat[12]+this.mat[1]*this.mat[7]*this.mat[10]*this.mat[12]+this.mat[2]*this.mat[5]*this.mat[11]*this.mat[12]-this.mat[1]*this.mat[6]*this.mat[11]*this.mat[12]-this.mat[3]*this.mat[6]*this.mat[8]*this.mat[13]+this.mat[2]*this.mat[7]*this.mat[8]*this.mat[13]+this.mat[3]*this.mat[4]*this.mat[10]*this.mat[13]-this.mat[0]*this.mat[7]*this.mat[10]*this.mat[13]-this.mat[2]*this.mat[4]*this.mat[11]*this.mat[13]+this.mat[0]*this.mat[6]*this.mat[11]*this.mat[13]+this.mat[3]*this.mat[5]*this.mat[8]*this.mat[14]-this.mat[1]*this.mat[7]*this.mat[8]*this.mat[14]-this.mat[3]*this.mat[4]*this.mat[9]*this.mat[14]+this.mat[0]*this.mat[7]*this.mat[9]*this.mat[14]+this.mat[1]*this.mat[4]*this.mat[11]*this.mat[14]-this.mat[0]*this.mat[5]*this.mat[11]*this.mat[14]-this.mat[2]*this.mat[5]*this.mat[8]*this.mat[15]+this.mat[1]*this.mat[6]*this.mat[8]*this.mat[15]+this.mat[2]*this.mat[4]*this.mat[9]*this.mat[15]-this.mat[0]*this.mat[6]*this.mat[9]*this.mat[15]-this.mat[1]*this.mat[4]*this.mat[10]*this.mat[15]+this.mat[0]*this.mat[5]*this.mat[10]*this.mat[15]}inverse(){const s=this.determinant();if(Math.abs(s)<1e-8)return new d;const t=new d;return t.mat[0]=(this.mat[6]*this.mat[11]*this.mat[13]-this.mat[7]*this.mat[10]*this.mat[13]+this.mat[7]*this.mat[9]*this.mat[14]-this.mat[5]*this.mat[11]*this.mat[14]-this.mat[6]*this.mat[9]*this.mat[15]+this.mat[5]*this.mat[10]*this.mat[15])/s,t.mat[1]=(this.mat[3]*this.mat[10]*this.mat[13]-this.mat[2]*this.mat[11]*this.mat[13]-this.mat[3]*this.mat[9]*this.mat[14]+this.mat[1]*this.mat[11]*this.mat[14]+this.mat[2]*this.mat[9]*this.mat[15]-this.mat[1]*this.mat[10]*this.mat[15])/s,t.mat[2]=(this.mat[2]*this.mat[7]*this.mat[13]-this.mat[3]*this.mat[6]*this.mat[13]+this.mat[3]*this.mat[5]*this.mat[14]-this.mat[1]*this.mat[7]*this.mat[14]-this.mat[2]*this.mat[5]*this.mat[15]+this.mat[1]*this.mat[6]*this.mat[15])/s,t.mat[3]=(this.mat[3]*this.mat[6]*this.mat[9]-this.mat[2]*this.mat[7]*this.mat[9]-this.mat[3]*this.mat[5]*this.mat[10]+this.mat[1]*this.mat[7]*this.mat[10]+this.mat[2]*this.mat[5]*this.mat[11]-this.mat[1]*this.mat[6]*this.mat[11])/s,t.mat[4]=(this.mat[7]*this.mat[10]*this.mat[12]-this.mat[6]*this.mat[11]*this.mat[12]-this.mat[7]*this.mat[8]*this.mat[14]+this.mat[4]*this.mat[11]*this.mat[14]+this.mat[6]*this.mat[8]*this.mat[15]-this.mat[4]*this.mat[10]*this.mat[15])/s,t.mat[5]=(this.mat[2]*this.mat[11]*this.mat[12]-this.mat[3]*this.mat[10]*this.mat[12]+this.mat[3]*this.mat[8]*this.mat[14]-this.mat[0]*this.mat[11]*this.mat[14]-this.mat[2]*this.mat[8]*this.mat[15]+this.mat[0]*this.mat[10]*this.mat[15])/s,t.mat[6]=(this.mat[3]*this.mat[6]*this.mat[12]-this.mat[2]*this.mat[7]*this.mat[12]-this.mat[3]*this.mat[4]*this.mat[14]+this.mat[0]*this.mat[7]*this.mat[14]+this.mat[2]*this.mat[4]*this.mat[15]-this.mat[0]*this.mat[6]*this.mat[15])/s,t.mat[7]=(this.mat[2]*this.mat[7]*this.mat[8]-this.mat[3]*this.mat[6]*this.mat[8]+this.mat[3]*this.mat[4]*this.mat[10]-this.mat[0]*this.mat[7]*this.mat[10]-this.mat[2]*this.mat[4]*this.mat[11]+this.mat[0]*this.mat[6]*this.mat[11])/s,t.mat[8]=(this.mat[5]*this.mat[11]*this.mat[12]-this.mat[7]*this.mat[9]*this.mat[12]+this.mat[7]*this.mat[8]*this.mat[13]-this.mat[4]*this.mat[11]*this.mat[13]-this.mat[5]*this.mat[8]*this.mat[15]+this.mat[4]*this.mat[9]*this.mat[15])/s,t.mat[9]=(this.mat[3]*this.mat[9]*this.mat[12]-this.mat[1]*this.mat[11]*this.mat[12]-this.mat[3]*this.mat[8]*this.mat[13]+this.mat[0]*this.mat[11]*this.mat[13]+this.mat[1]*this.mat[8]*this.mat[15]-this.mat[0]*this.mat[9]*this.mat[15])/s,t.mat[10]=(this.mat[1]*this.mat[7]*this.mat[12]-this.mat[3]*this.mat[5]*this.mat[12]+this.mat[3]*this.mat[4]*this.mat[13]-this.mat[0]*this.mat[7]*this.mat[13]-this.mat[1]*this.mat[4]*this.mat[15]+this.mat[0]*this.mat[5]*this.mat[15])/s,t.mat[11]=(this.mat[3]*this.mat[5]*this.mat[8]-this.mat[1]*this.mat[7]*this.mat[8]-this.mat[3]*this.mat[4]*this.mat[9]+this.mat[0]*this.mat[7]*this.mat[9]+this.mat[1]*this.mat[4]*this.mat[11]-this.mat[0]*this.mat[5]*this.mat[11])/s,t.mat[12]=(this.mat[6]*this.mat[9]*this.mat[12]-this.mat[5]*this.mat[10]*this.mat[12]-this.mat[6]*this.mat[8]*this.mat[13]+this.mat[4]*this.mat[10]*this.mat[13]+this.mat[5]*this.mat[8]*this.mat[14]-this.mat[4]*this.mat[9]*this.mat[14])/s,t.mat[13]=(this.mat[1]*this.mat[10]*this.mat[12]-this.mat[2]*this.mat[9]*this.mat[12]+this.mat[2]*this.mat[8]*this.mat[13]-this.mat[0]*this.mat[10]*this.mat[13]-this.mat[1]*this.mat[8]*this.mat[14]+this.mat[0]*this.mat[9]*this.mat[14])/s,t.mat[14]=(this.mat[2]*this.mat[5]*this.mat[12]-this.mat[1]*this.mat[6]*this.mat[12]-this.mat[2]*this.mat[4]*this.mat[13]+this.mat[0]*this.mat[6]*this.mat[13]+this.mat[1]*this.mat[4]*this.mat[14]-this.mat[0]*this.mat[5]*this.mat[14])/s,t.mat[15]=(this.mat[1]*this.mat[6]*this.mat[8]-this.mat[2]*this.mat[5]*this.mat[8]+this.mat[2]*this.mat[4]*this.mat[9]-this.mat[0]*this.mat[6]*this.mat[9]-this.mat[1]*this.mat[4]*this.mat[10]+this.mat[0]*this.mat[5]*this.mat[10])/s,t}invert(){const s=this.inverse();this.copy(s)}transpose(){return d.fromRowMajor(this.mat[0],this.mat[1],this.mat[2],this.mat[3],this.mat[4],this.mat[5],this.mat[6],this.mat[7],this.mat[8],this.mat[9],this.mat[10],this.mat[11],this.mat[12],this.mat[13],this.mat[14],this.mat[15])}};let B=d;B.IDENTITY=new d;class D{constructor(){this.children=[],this.position=new o,this.rotation=new C,this.scale=new o(1,1,1),this.visible=!0,this.matrixAutoUpdate=!0,this.matrix=new B,this.worldMatrix=new B}draw(t,e,i){!this.visible||this.children.forEach(r=>{r.draw(this,e,i)})}postRender(){this.children.forEach(t=>{t.postRender()})}computeWorldTransform(t){this.matrixAutoUpdate&&(this.matrix.makeTransform(this.position,this.rotation,this.scale),this.worldMatrix.copy(t.worldMatrix),this.worldMatrix.multiply(this.matrix)),this.children.forEach(e=>{e.computeWorldTransform(this)})}add(t){this.children.push(t)}remove(t){const e=this.children.indexOf(t);return e==-1?null:this.children.splice(e,1)[0]}setLights(t){this.children.forEach(e=>{e.setLights(t)})}translate(t){this.position.add(this.rotation.rotate(t))}translateX(t){this.position.add(this.rotation.rotate(new o(t,0,0)))}translateY(t){this.position.add(this.rotation.rotate(new o(0,t,0)))}translateZ(t){this.position.add(this.rotation.rotate(new o(0,0,t)))}lookAt(t,e=o.UP){const i=B.lookAt(this.position,t,e);this.rotation.setMatrix(i)}getWorldMatrix(){return this.worldMatrix}getLocalMatrix(){return this.matrix}setWorldMatrix(t){this.worldMatrix.copy(t)}setLocalMatrix(t){this.matrix.copy(t)}}class W extends D{constructor(t=60,e=1920/1080,i=.1,r=100){super(),this.projectionMatrix=new B,this.viewMatrix=new B,this.fov=t,this.aspectRatio=e,this.near=i,this.far=r,this.projectionMatrix.makePerspective(t,e,i,r)}getProjectionMatrix(){return this.projectionMatrix}getViewMatrix(){return this.viewMatrix}setPerspectiveCamera(t,e,i,r){this.fov=t,this.aspectRatio=e,this.near=i,this.far=r,this.projectionMatrix.makePerspective(t,e,i,r)}computeWorldTransform(t){super.computeWorldTransform(t),this.viewMatrix=this.worldMatrix.inverse()}getFov(){return this.fov}getAspectRatio(){return this.aspectRatio}getNear(){return this.near}getFar(){return this.far}onMouseDown(t){}onMouseUp(t){}onMouseMove(t){}onMouseWheel(t){}onKeyDown(t){}onKeyUp(t){}}class q{constructor(){this.lights=[],this.lightTypes=[],this.lightPositions=[],this.ambientIntensities=[],this.diffuseIntensities=[],this.specularIntensities=[]}clear(){this.lights=[],this.lightTypes=[],this.lightPositions=[],this.ambientIntensities=[],this.diffuseIntensities=[],this.specularIntensities=[]}addLight(t){this.lights.some(i=>i==t)||this.lights.push(t)}getNumLights(){return this.lights.length}updateLights(){this.lights.forEach(t=>{if(t.visible){const e=new o;e.applyMatrix(t.getWorldMatrix()),this.lightPositions.push(e.x,e.y,e.z),this.lightTypes.push(t.getType()),this.ambientIntensities.push(t.ambientIntensity.r,t.ambientIntensity.g,t.ambientIntensity.b),this.diffuseIntensities.push(t.diffuseIntensity.r,t.diffuseIntensity.g,t.diffuseIntensity.b),this.specularIntensities.push(t.specularIntensity.r,t.specularIntensity.g,t.specularIntensity.b)}else{const e=new o;e.applyMatrix(t.getWorldMatrix()),this.lightPositions.push(e.x,e.y,e.z),this.lightTypes.push(t.getType()),this.ambientIntensities.push(0,0,0),this.diffuseIntensities.push(0,0,0),this.specularIntensities.push(0,0,0)}})}}class tt{constructor(){this.root=new D,this.lightManager=new q}draw(t){t.computeWorldTransform(this.root),this.computeWorldTransforms(),this.lightManager.clear(),this.root.setLights(this.lightManager),this.lightManager.updateLights(),this.root.children.forEach(e=>{e.draw(this.root,t,this.lightManager)})}postRender(){this.root.children.forEach(t=>{t.postRender()})}add(t){this.root.add(t)}remove(t){this.root.remove(t)}computeWorldTransforms(){this.root.children.forEach(t=>{t.computeWorldTransform(this.root)})}}class I{static getInstance(){return I.instance}constructor(){I.instance=this,this.time=Date.now(),this.camera=new W,this.scene=new tt,this.renderer=new J,this.renderer.resize(window.innerWidth,window.innerHeight,this.camera.getAspectRatio()),window.addEventListener("resize",()=>{this.resize()},!1),window.addEventListener("mousedown",t=>{this.onMouseDownEventHandler(t)}),window.addEventListener("mouseup",t=>{this.onMouseUpEventHandler(t)}),window.addEventListener("mousemove",t=>{this.onMouseMoveEventHandler(t)}),window.addEventListener("wheel",t=>{this.onMouseWheelEventHandler(t)}),window.addEventListener("keydown",t=>{this.onKeyDownEventHandler(t)}),window.addEventListener("keyup",t=>{this.onKeyUpEventHandler(t)})}start(){this.createScene(),this.mainLoop()}mainLoop(){this.update((Date.now()-this.time)/1e3),this.renderer.render(this.scene,this.camera),this.scene.postRender(),window.requestAnimationFrame(()=>this.mainLoop())}resize(){this.renderer.resize(window.innerWidth,window.innerHeight,this.camera.getAspectRatio())}onMouseDown(t){}onMouseUp(t){}onMouseMove(t){}onMouseWheel(t){}onKeyDown(t){}onKeyUp(t){}onMouseDownEventHandler(t){this.camera.onMouseDown(t),this.onMouseDown(t)}onMouseUpEventHandler(t){this.camera.onMouseUp(t),this.onMouseUp(t)}onMouseMoveEventHandler(t){this.camera.onMouseMove(t),this.onMouseMove(t)}onMouseWheelEventHandler(t){this.camera.onMouseWheel(t),this.onMouseWheel(t)}onKeyDownEventHandler(t){this.camera.onKeyDown(t),this.onKeyDown(t)}onKeyUpEventHandler(t){this.camera.onKeyUp(t),this.onKeyUp(t)}}class it extends W{constructor(t=1,e=60,i=1920/1080,r=.1,n=100){super(e,i,r,n),this.mouseDrag=!1,this.cameraOrbitX=new C,this.cameraOrbitY=new C,this.cameraDistance=t,this.updateCameraOrbit()}onMouseDown(t){t.target.localName=="canvas"&&(this.mouseDrag=!0)}onMouseUp(t){this.mouseDrag=!1}onMouseMove(t){this.mouseDrag&&(this.cameraOrbitX.multiply(C.makeRotationX(-t.movementY*Math.PI/180)),this.cameraOrbitY.multiply(C.makeRotationY(-t.movementX*Math.PI/180)),this.updateCameraOrbit())}onMouseWheel(t){this.cameraDistance+=t.deltaY/1e3,this.updateCameraOrbit()}updateCameraOrbit(){this.rotation.copy(this.cameraOrbitX),this.rotation.multiply(this.cameraOrbitY),this.position.set(0,0,this.cameraDistance),this.position.rotate(this.rotation)}}class Y{constructor(t=new o,e=new o(0,0,-1)){this.origin=t,this.direction=e}set(t,e){this.origin=t,this.direction=e}}class V{constructor(t=new o(-.5,-.5,-.5),e=new o(.5,.5,.5)){this.min=t,this.max=e}}class j{constructor(t=new o,e=1){this.center=t,this.radius=e}}class st{constructor(t=new Y){this.ray=t}setPickRay(t,e){this.ray.origin.copy(e.position),this.ray.direction.set(t.x,t.y,-1),this.ray.direction.applyMatrix(e.getProjectionMatrix().inverse()),this.ray.direction.applyMatrix(e.getWorldMatrix()),this.ray.direction.subtract(this.ray.origin),this.ray.direction.normalize()}intersectsPlane(t){const e=this.ray.direction.dot(t.normal);if(Math.abs(e)>1e-6){const r=o.subtract(t.point,this.ray.origin).dot(t.normal)/e;if(r>0){const n=o.multiplyScalar(this.ray.direction,r);return n.add(this.ray.origin),n}}return null}intersectsSphere(t){const e=o.subtract(t.center,this.ray.origin),i=e.dot(this.ray.direction),r=t.radius*t.radius,n=e.dot(e)-i*i;if(n>r)return null;const h=Math.sqrt(r-n),u=i-h,l=i+h;if(u<0&&l<0)return null;const m=this.ray.direction.clone();return u<l?m.multiplyScalar(u):m.multiplyScalar(l),m.add(this.ray.origin),m}intersectsBox(t){let e=(t.min.x-this.ray.origin.x)/this.ray.direction.x,i=(t.max.x-this.ray.origin.x)/this.ray.direction.x;if(e>i){const m=e;e=i,i=m}let r=(t.min.y-this.ray.origin.y)/this.ray.direction.y,n=(t.max.y-this.ray.origin.y)/this.ray.direction.y;if(r>n){const m=r;r=n,n=m}if(e>n||r>i)return null;r>e&&(e=r),n<i&&(i=n);let h=(t.min.z-this.ray.origin.z)/this.ray.direction.z,u=(t.max.z-this.ray.origin.z)/this.ray.direction.z;if(h>u){const m=h;h=u,u=m}if(e>u||h>i)return null;h>e&&(e=h),u<i&&(i=u);const l=o.multiplyScalar(this.ray.direction,e);return l.add(this.ray.origin),l}intersectsMeshBoundingBox(t){const e=new V;return e.min.copy(t.boundingBox.min),e.max.copy(t.boundingBox.max),e.min.applyMatrix(t.getWorldMatrix()),e.max.applyMatrix(t.getWorldMatrix()),this.intersectsBox(e)}intersectsMeshBoundingSphere(t){const e=new j;return e.radius=t.boundingSphere.radius,e.center.copy(t.boundingSphere.center),e.center.applyMatrix(t.getWorldMatrix()),this.intersectsSphere(e)}intersectsMesh(t){const e=t.getVertices(),i=t.getIndices(),r=new Y(this.ray.origin.clone(),this.ray.direction.clone());r.origin.applyMatrix(t.getWorldMatrix().inverse()),r.direction.rotate(t.rotation.inverse());const n=[];for(let h=0;h<i.length;h+=3){const u=this.intersectsTriangle(r,new o(e[i[h]*3],e[i[h]*3+1],e[i[h]*3+2]),new o(e[i[h+1]*3],e[i[h+1]*3+1],e[i[h+1]*3+2]),new o(e[i[h+2]*3],e[i[h+2]*3+1],e[i[h+2]*3+2]));u&&(u.applyMatrix(t.getWorldMatrix()),n.push(u))}if(n.length==0)return null;{let h=0,u=this.ray.origin.distanceTo(n[0]);for(let l=1;l<n.length;l++){const m=this.ray.origin.distanceTo(n[l]);m<u&&(h=l,u=m)}return n[h]}}intersectsTriangle(t,e,i,r){const h=o.subtract(i,e),u=o.subtract(r,e),l=o.cross(t.direction,u),m=h.dot(l);if(m>-1e-7&&m<1e-7)return null;const y=1/m,a=o.subtract(t.origin,e),w=y*a.dot(l);if(w<0||w>1)return null;const x=o.cross(a,h),p=y*t.direction.dot(x);if(p<0||w+p>1)return null;const b=y*u.dot(x);if(b>1e-7){const M=t.direction.clone();return M.multiplyScalar(b),M.add(t.origin),M}return null}}const U=class{constructor(s=0,t=0,e=0){this.r=s,this.g=t,this.b=e}set(s,t,e){this.r=s,this.g=t,this.b=e}copy(s){this.r=s.r,this.g=s.g,this.b=s.b}};let g=U;g.WHITE=new U(1,1,1);g.BLACK=new U(0,0,0);g.RED=new U(1,0,0);g.GREEN=new U(0,1,0);g.BLUE=new U(0,0,1);g.YELLOW=new U(1,1,0);g.PURPLE=new U(1,0,1);g.CYAN=new U(0,1,1);class et{constructor(t=new o,e=new o(0,0,-1)){this.point=t,this.normal=e}}var rt=`#version 300 es

precision mediump float;

#define POINT_LIGHT 0
#define DIRECTIONAL_LIGHT 1

const int MAX_LIGHTS = 16;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 normalMatrix;
uniform vec3 eyePosition;

uniform int numLights;
uniform int lightTypes[MAX_LIGHTS];
uniform vec3 lightPositions[MAX_LIGHTS];
uniform vec3 ambientIntensities[MAX_LIGHTS];
uniform vec3 diffuseIntensities[MAX_LIGHTS];
uniform vec3 specularIntensities[MAX_LIGHTS];

uniform vec3 kAmbient;
uniform vec3 kDiffuse;
uniform vec3 kSpecular;
uniform float shininess;

in vec3 position;
in vec3 normal;
in vec4 color;
in vec2 texCoord;

out vec4 vertColor;
out vec2 uv;

void main() 
{
    
    vec3 worldPosition = (modelMatrix * vec4(position, 1)).xyz;

    vec3 illumination = vec3(0, 0, 0);
    for(int i=0; i < numLights; i++)
    {
        
        illumination += kAmbient * ambientIntensities[i];
        
        
        vec3 n = normalize((normalMatrix * vec4(normal, 0)).xyz);

        
        vec3 l;
        if(lightTypes[i] == DIRECTIONAL_LIGHT)
            l = normalize(lightPositions[i]);
        else
            l = normalize(lightPositions[i] - worldPosition);

        
        float diffuseComponent = max(dot(n, l), 0.0);
        illumination += diffuseComponent * kDiffuse * diffuseIntensities[i];

        
        vec3 e = normalize(eyePosition - worldPosition);

        
        vec3 r = reflect(-l, n);

        
        float specularComponent = pow(max(dot(e, r), 0.0), shininess);
        illumination += specularComponent * kSpecular * specularIntensities[i];
    }

    vertColor = color;
    vertColor.rgb *= illumination;

    uv = texCoord.xy; 

    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition, 1);
}`,nt=`#version 300 es

precision mediump float;

uniform int useTexture;
uniform sampler2D textureImage;

in vec4 vertColor;
in vec2 uv;

out vec4 fragColor;

void main() 
{
    fragColor = vertColor;

    if(useTexture != 0)
    {
        fragColor *= texture(textureImage, uv);
    }
}`,H=(s=>(s[s.FRONT=0]="FRONT",s[s.BACK=1]="BACK",s[s.DOUBLE=2]="DOUBLE",s))(H||{});class v{constructor(){this.visible=!0,this.side=0,this.gl=I.getInstance().renderer.gl}initialize(){if(this.side==2){this.gl.disable(this.gl.CULL_FACE);return}this.gl.enable(this.gl.CULL_FACE),this.side==0?this.gl.cullFace(this.gl.BACK):this.gl.cullFace(this.gl.FRONT)}}class k{constructor(t,e){this.vertexSource=t,this.fragmentSource=e,this.vertexShader=null,this.fragmentShader=null,this.shaderProgram=null,this.initialized=!1}initialize(t){this.initialized||(this.initialized=!0,this.vertexShader=this.createVertexShader(t,this.vertexSource),this.fragmentShader=this.createFragmentShader(t,this.fragmentSource),this.vertexShader&&this.fragmentShader&&(this.shaderProgram=this.createShaderProgram(t,this.vertexShader,this.fragmentShader)))}createVertexShader(t,e){const i=t.createShader(t.VERTEX_SHADER);return i?(t.shaderSource(i,e),t.compileShader(i),t.getShaderParameter(i,t.COMPILE_STATUS)||(console.error("Error: unable to load vertex shader"),console.error(t.getShaderInfoLog(i)))):console.error("Error: unable to create vertex shader"),i}createFragmentShader(t,e){const i=t.createShader(t.FRAGMENT_SHADER);return i?(t.shaderSource(i,e),t.compileShader(i),t.getShaderParameter(i,t.COMPILE_STATUS)||(console.error("Error: unable to load fragment shader"),console.error(t.getShaderInfoLog(i)))):console.error("Error: unable to create fragment shader"),i}createShaderProgram(t,e,i){let r=null;if(e&&i){if(r=t.createProgram(),!r)return console.error("Error: could not create shader program"),null;if(t.attachShader(r,e),t.attachShader(r,i),t.linkProgram(r),!t.getProgramParameter(r,t.LINK_STATUS))return console.error("Error: could not link shader program"),console.error(t.getProgramInfoLog(r)),null}return r}getProgram(){return this.shaderProgram}getAttribute(t,e){return this.shaderProgram?t.getAttribLocation(this.shaderProgram,e):-1}getUniform(t,e){return this.shaderProgram?t.getUniformLocation(this.shaderProgram,e):null}}const f=class extends v{constructor(){super(),this.texture=null,this.ambientColor=new g(1,1,1),this.diffuseColor=new g(1,1,1),this.specularColor=new g(0,0,0),this.shininess=30,f.shader.initialize(this.gl),this.kAmbientUniform=f.shader.getUniform(this.gl,"kAmbient"),this.kDiffuseUniform=f.shader.getUniform(this.gl,"kDiffuse"),this.kSpecularUniform=f.shader.getUniform(this.gl,"kSpecular"),this.shininessUniform=f.shader.getUniform(this.gl,"shininess"),this.textureUniform=f.shader.getUniform(this.gl,"textureImage"),this.useTextureUniform=f.shader.getUniform(this.gl,"useTexture"),this.eyePositionUniform=f.shader.getUniform(this.gl,"eyePosition"),this.viewUniform=f.shader.getUniform(this.gl,"viewMatrix"),this.modelUniform=f.shader.getUniform(this.gl,"modelMatrix"),this.projectionUniform=f.shader.getUniform(this.gl,"projectionMatrix"),this.normalUniform=f.shader.getUniform(this.gl,"normalMatrix"),this.numLightsUniform=f.shader.getUniform(this.gl,"numLights"),this.lightTypesUniform=f.shader.getUniform(this.gl,"lightTypes"),this.lightPositionsUniform=f.shader.getUniform(this.gl,"lightPositions"),this.ambientIntensitiesUniform=f.shader.getUniform(this.gl,"ambientIntensities"),this.diffuseIntensitiesUniform=f.shader.getUniform(this.gl,"diffuseIntensities"),this.specularIntensitiesUniform=f.shader.getUniform(this.gl,"specularIntensities"),this.positionAttribute=f.shader.getAttribute(this.gl,"position"),this.normalAttribute=f.shader.getAttribute(this.gl,"normal"),this.colorAttribute=f.shader.getAttribute(this.gl,"color"),this.texCoordAttribute=f.shader.getAttribute(this.gl,"texCoord")}draw(s,t,e,i){if(!this.visible||s.triangleCount==0)return;this.initialize(),this.gl.useProgram(f.shader.getProgram());const r=new o;r.applyMatrix(e.getWorldMatrix()),this.gl.uniform3f(this.eyePositionUniform,r.x,r.y,r.z),this.gl.uniformMatrix4fv(this.modelUniform,!1,t.getWorldMatrix().mat),this.gl.uniformMatrix4fv(this.viewUniform,!1,e.getViewMatrix().mat),this.gl.uniformMatrix4fv(this.projectionUniform,!1,e.getProjectionMatrix().mat),this.gl.uniformMatrix4fv(this.normalUniform,!1,t.getWorldMatrix().inverse().transpose().mat),this.gl.uniform3f(this.kAmbientUniform,this.ambientColor.r,this.ambientColor.g,this.ambientColor.b),this.gl.uniform3f(this.kDiffuseUniform,this.diffuseColor.r,this.diffuseColor.g,this.diffuseColor.b),this.gl.uniform3f(this.kSpecularUniform,this.specularColor.r,this.specularColor.g,this.specularColor.b),this.gl.uniform1f(this.shininessUniform,this.shininess),this.gl.uniform1i(this.numLightsUniform,i.getNumLights()),this.gl.uniform1iv(this.lightTypesUniform,i.lightTypes),this.gl.uniform3fv(this.lightPositionsUniform,i.lightPositions),this.gl.uniform3fv(this.ambientIntensitiesUniform,i.ambientIntensities),this.gl.uniform3fv(this.diffuseIntensitiesUniform,i.diffuseIntensities),this.gl.uniform3fv(this.specularIntensitiesUniform,i.specularIntensities),this.gl.enableVertexAttribArray(this.positionAttribute),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s.positionBuffer),this.gl.vertexAttribPointer(this.positionAttribute,3,this.gl.FLOAT,!1,0,0),this.gl.enableVertexAttribArray(this.normalAttribute),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s.normalBuffer),this.gl.vertexAttribPointer(this.normalAttribute,3,this.gl.FLOAT,!1,0,0),this.gl.enableVertexAttribArray(this.colorAttribute),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s.colorBuffer),this.gl.vertexAttribPointer(this.colorAttribute,4,this.gl.FLOAT,!1,0,0),this.texture?(this.gl.uniform1i(this.useTextureUniform,1),this.gl.activeTexture(this.gl.TEXTURE0+this.texture.id),this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture.texture),this.gl.uniform1i(this.textureUniform,this.texture.id),this.gl.enableVertexAttribArray(this.texCoordAttribute),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s.texCoordBuffer),this.gl.vertexAttribPointer(this.texCoordAttribute,2,this.gl.FLOAT,!1,0,0)):this.gl.uniform1i(this.useTextureUniform,0),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,s.indexBuffer),this.gl.drawElements(this.gl.TRIANGLES,s.triangleCount*3,this.gl.UNSIGNED_SHORT,0)}};let F=f;F.shader=new k(rt,nt);class S extends D{constructor(){super(),this.gl=I.getInstance().renderer.gl,this.positionBuffer=this.gl.createBuffer(),this.normalBuffer=this.gl.createBuffer(),this.colorBuffer=this.gl.createBuffer(),this.indexBuffer=this.gl.createBuffer(),this.texCoordBuffer=this.gl.createBuffer(),this.positionBufferDirty=!1,this.normalBufferDirty=!1,this.colorBufferDirty=!1,this.indexBufferDirty=!1,this.texCoordBufferDirty=!1,this.vertexCount=0,this.triangleCount=0,this.material=new F,this.boundingBox=new V,this.boundingSphere=new j}draw(t,e,i){!this.visible||(this.material.draw(this,this,e,i),this.children.forEach(r=>{r.draw(this,e,i)}))}postRender(){this.positionBufferDirty=!1,this.normalBufferDirty=!1,this.colorBufferDirty=!1,this.indexBufferDirty=!1,this.children.forEach(t=>{t.postRender()})}setVertices(t){if(t.length>0){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer);let e;typeof t[0]=="number"?e=t:(e=[],t.forEach(i=>{e.push(i.x,i.y,i.z)})),this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(e),this.gl.DYNAMIC_DRAW),this.vertexCount=e.length/3,this.computeBounds(t),this.positionBufferDirty=!0}}setNormals(t){if(t.length>0){if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.normalBuffer),typeof t[0]=="number")this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(t),this.gl.DYNAMIC_DRAW);else{const e=[];t.forEach(i=>{e.push(i.x,i.y,i.z)}),this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(e),this.gl.DYNAMIC_DRAW)}this.normalBufferDirty=!0}}setColors(t){if(t.length>0){if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.colorBuffer),typeof t[0]=="number")this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(t),this.gl.DYNAMIC_DRAW);else{const e=[];t.forEach(i=>{e.push(i.r,i.g,i.b,i.a)}),this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(e),this.gl.DYNAMIC_DRAW)}this.colorBufferDirty=!0}}setTextureCoordinates(t){if(t.length>0){if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.texCoordBuffer),typeof t[0]=="number")this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(t),this.gl.DYNAMIC_DRAW);else{const e=[];t.forEach(i=>{e.push(i.x,i.y)}),this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(e),this.gl.DYNAMIC_DRAW)}this.texCoordBufferDirty=!0}}setIndices(t){if(t.length>0){if(this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer),typeof t[0]=="number")this.triangleCount=t.length/3,this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(t),this.gl.DYNAMIC_DRAW);else{this.triangleCount=t.length;const e=[];t.forEach(i=>{e.push(i.x,i.y,i.z)}),this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(e),this.gl.DYNAMIC_DRAW)}this.indexBufferDirty=!0}}setArrayBuffer(t,e){if(t.length>0)if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,e),typeof t[0]=="number")this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(t),this.gl.DYNAMIC_DRAW);else{const i=[];t.forEach(r=>{i.push(r.x,r.y,r.z)}),this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(i),this.gl.DYNAMIC_DRAW)}}getVertices(){const t=new Float32Array(this.vertexCount*3);return this.gl.bindBuffer(this.gl.COPY_READ_BUFFER,this.positionBuffer),this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER,0,t),[...t]}getNormals(){const t=new Float32Array(this.vertexCount*3);return this.gl.bindBuffer(this.gl.COPY_READ_BUFFER,this.normalBuffer),this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER,0,t),[...t]}getColors(){const t=new Float32Array(this.vertexCount*4);return this.gl.bindBuffer(this.gl.COPY_READ_BUFFER,this.colorBuffer),this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER,0,t),[...t]}getTextureCoordinates(){const t=new Float32Array(this.vertexCount*2);return this.gl.bindBuffer(this.gl.COPY_READ_BUFFER,this.texCoordBuffer),this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER,0,t),[...t]}getIndices(){const t=new Uint16Array(this.triangleCount*3);return this.gl.bindBuffer(this.gl.COPY_READ_BUFFER,this.indexBuffer),this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER,0,t),[...t]}getArrayBuffer(t){const e=new Float32Array(this.vertexCount*3);return this.gl.bindBuffer(this.gl.COPY_READ_BUFFER,t),this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER,0,e),[...e]}createDefaultVertexColors(){const t=[];for(let e=0;e<this.vertexCount;e++)t.push(1,1,1,1);this.setColors(t)}computeBounds(t){if(t||(t=this.getVertices()),t.length!=0){if(typeof t[0]=="number"){const e=t;this.boundingBox.max.set(e[0],e[1],e[2]),this.boundingBox.min.set(e[0],e[1],e[2]);for(let i=0;i<e.length;i+=3)e[i]>this.boundingBox.max.x&&(this.boundingBox.max.x=e[i]),e[i]<this.boundingBox.min.x&&(this.boundingBox.min.x=e[i]),e[i+1]>this.boundingBox.max.y&&(this.boundingBox.max.y=e[i+1]),e[i+1]<this.boundingBox.min.y&&(this.boundingBox.min.y=e[i+1]),e[i+2]>this.boundingBox.max.z&&(this.boundingBox.max.z=e[i+2]),e[i+2]<this.boundingBox.min.z&&(this.boundingBox.min.z=e[i+2])}else this.boundingBox.max.copy(t[0]),this.boundingBox.min.copy(t[0]),t.forEach(e=>{e.x>this.boundingBox.max.x&&(this.boundingBox.max.x=e.x),e.x<this.boundingBox.min.x&&(this.boundingBox.min.x=e.x),e.y>this.boundingBox.max.y&&(this.boundingBox.max.y=e.y),e.y<this.boundingBox.min.y&&(this.boundingBox.min.y=e.y),e.z>this.boundingBox.max.z&&(this.boundingBox.max.z=e.z),e.z<this.boundingBox.min.z&&(this.boundingBox.min.z=e.z)});if(this.boundingSphere.center.copy(this.boundingBox.min),this.boundingSphere.center.add(this.boundingBox.max),this.boundingSphere.center.multiplyScalar(.5),this.boundingSphere.radius=0,typeof t[0]=="number"){const e=t;for(let i=0;i<e.length;i+=3){const r=Math.sqrt((e[i]-this.boundingSphere.center.x)*(e[i]-this.boundingSphere.center.x)+(e[i+1]-this.boundingSphere.center.y)*(e[i+1]-this.boundingSphere.center.y)+(e[i+2]-this.boundingSphere.center.z)*(e[i+2]-this.boundingSphere.center.z));r>this.boundingSphere.radius&&(this.boundingSphere.radius=r)}}else t.forEach(e=>{const i=e.distanceTo(this.boundingSphere.center);i>this.boundingSphere.radius&&(this.boundingSphere.radius=i)})}}}class ht extends D{constructor(t){super(),this.baseMesh=t,this.material=t.material}getBaseMesh(){return this.baseMesh}draw(t,e,i){!this.visible||(this.material.draw(this.baseMesh,this,e,i),this.children.forEach(r=>{r.draw(this,e,i)}))}postRender(){this.children.forEach(t=>{t.postRender()})}}class X extends S{constructor(t=1,e=1,i=1){super(),this.width=t,this.height=e,this.depth=i,this.createVertices(this.width,this.height,this.depth),this.createNormals(),this.createTextureCoords(),this.createIndices(),this.createDefaultVertexColors()}createVertices(t,e,i){const r=[];r.push(-t/2,-e/2,i/2),r.push(t/2,-e/2,i/2),r.push(t/2,e/2,i/2),r.push(-t/2,e/2,i/2),r.push(-t/2,-e/2,-i/2),r.push(t/2,-e/2,-i/2),r.push(t/2,e/2,-i/2),r.push(-t/2,e/2,-i/2),r.push(-t/2,-e/2,-i/2),r.push(-t/2,-e/2,i/2),r.push(-t/2,e/2,i/2),r.push(-t/2,e/2,-i/2),r.push(t/2,-e/2,-i/2),r.push(t/2,-e/2,i/2),r.push(t/2,e/2,i/2),r.push(t/2,e/2,-i/2),r.push(-t/2,e/2,i/2),r.push(t/2,e/2,i/2),r.push(t/2,e/2,-i/2),r.push(-t/2,e/2,-i/2),r.push(-t/2,-e/2,i/2),r.push(t/2,-e/2,i/2),r.push(t/2,-e/2,-i/2),r.push(-t/2,-e/2,-i/2),this.setVertices(r)}createNormals(){const t=[];t.push(0,0,1),t.push(0,0,1),t.push(0,0,1),t.push(0,0,1),t.push(0,0,-1),t.push(0,0,-1),t.push(0,0,-1),t.push(0,0,-1),t.push(-1,0,0),t.push(-1,0,0),t.push(-1,0,0),t.push(-1,0,0),t.push(1,0,0),t.push(1,0,0),t.push(1,0,0),t.push(1,0,0),t.push(0,1,0),t.push(0,1,0),t.push(0,1,0),t.push(0,1,0),t.push(0,-1,0),t.push(0,-1,0),t.push(0,-1,0),t.push(0,-1,0),this.setNormals(t)}createIndices(){const t=[];t.push(0,1,2),t.push(2,3,0),t.push(4,6,5),t.push(6,4,7),t.push(8,9,10),t.push(10,11,8),t.push(12,14,13),t.push(14,12,15),t.push(16,17,18),t.push(18,19,16),t.push(20,22,21),t.push(22,20,23),this.setIndices(t)}createTextureCoords(){const t=[];t.push(0,1),t.push(1,1),t.push(1,0),t.push(0,0),t.push(1,1),t.push(0,1),t.push(0,0),t.push(1,0),t.push(0,1),t.push(1,1),t.push(1,0),t.push(0,0),t.push(1,1),t.push(0,1),t.push(0,0),t.push(1,0),t.push(0,1),t.push(1,1),t.push(1,0),t.push(0,0),t.push(1,1),t.push(0,1),t.push(0,0),t.push(1,0),this.setTextureCoordinates(t)}}class P extends S{constructor(t=1,e=3){super(),this.radius=t,this.subdivisions=e,this.createSphere(this.radius,this.subdivisions)}createSphere(t,e){let i=[],r=[];const n=[],h=[],u=(1+Math.sqrt(5))*.5,l=1,m=1/u;i.push(new o(0,m,-l)),i.push(new o(m,l,0)),i.push(new o(-m,l,0)),i.push(new o(0,m,l)),i.push(new o(0,-m,l)),i.push(new o(-l,0,m)),i.push(new o(0,-m,-l)),i.push(new o(l,0,-m)),i.push(new o(l,0,m)),i.push(new o(-l,0,-m)),i.push(new o(m,-l,0)),i.push(new o(-m,-l,0));for(let a=0;a<i.length;a++)i[a].normalize();r.push(2,1,0),r.push(1,2,3),r.push(5,4,3),r.push(4,8,3),r.push(7,6,0),r.push(6,9,0),r.push(11,10,4),r.push(10,11,6),r.push(9,5,2),r.push(5,9,11),r.push(8,7,1),r.push(7,8,10),r.push(2,5,3),r.push(8,1,3),r.push(9,2,0),r.push(1,7,0),r.push(11,9,6),r.push(7,10,6),r.push(5,11,4),r.push(10,8,4);for(let a=0;a<e;a++){const w=[];for(let x=0;x<r.length/3;x++){const p=x*3,b=this.createCentroids(i,r[p],r[p+1],r[p+2]);i.push(...b);const M=this.subdivide(r[p],r[p+1],r[p+2],i.length-3,i.length-2,i.length-1);w.push(...M)}r=w}for(let a=0;a<i.length;a++)i[a].multiplyScalar(t);[i,r]=this.mergeSharedVertices(i,r);for(let a=0;a<i.length;a++){n.push(o.normalize(i[a]));const w=1-(i[a].y+t)/(2*t),x=new o(i[a].x,0,i[a].z);x.normalize();let p=Math.acos(o.FORWARD.dot(x));x.x>0&&(p=Math.PI*2-p);const b=p/(Math.PI*2);h.push(b,w)}const y=r.length;for(let a=0;a<y;a+=3)this.isSeamVertex(a,i,r)?this.isEndVertex(a+1,i,r)&&this.isEndVertex(a+2,i,r)?(i.push(o.copy(i[r[a]])),n.push(o.normalize(i[r[a]])),h.push(1,h[r[a]*2+1]),r[a]=i.length-1):this.isEndVertex(a+1,i,r)?(i.push(o.copy(i[r[a]])),n.push(o.normalize(i[r[a]])),h.push(1,h[r[a]*2+1]),i.push(o.copy(i[r[a+2]])),n.push(o.normalize(i[r[a+2]])),h.push(1,h[r[a+2]*2+1]),r[a]=i.length-2,r[a+2]=i.length-1):this.isEndVertex(a+2,i,r)&&(i.push(o.copy(i[r[a]])),n.push(o.normalize(i[r[a]])),h.push(1,h[r[a]*2+1]),i.push(o.copy(i[r[a+1]])),n.push(o.normalize(i[r[a+1]])),h.push(1,h[r[a+1]*2+1]),r[a]=i.length-2,r[a+1]=i.length-1):this.isSeamVertex(a+1,i,r)?this.isEndVertex(a,i,r)&&this.isEndVertex(a+2,i,r)?(i.push(o.copy(i[r[a+1]])),n.push(o.normalize(i[r[a+1]])),h.push(1,h[r[a+1]*2+1]),r[a+1]=i.length-1):this.isEndVertex(a,i,r)?(i.push(o.copy(i[r[a+1]])),n.push(o.normalize(i[r[a+1]])),h.push(1,h[r[a+1]*2+1]),i.push(o.copy(i[r[a+2]])),n.push(o.normalize(i[r[a+2]])),h.push(1,h[r[a+2]*2+1]),r[a+1]=i.length-2,r[a+2]=i.length-1):this.isEndVertex(a+2,i,r)&&(i.push(o.copy(i[r[a]])),n.push(o.normalize(i[r[a]])),h.push(1,h[r[a]*2+1]),i.push(o.copy(i[r[a+1]])),n.push(o.normalize(i[r[a+1]])),h.push(1,h[r[a+1]*2+1]),r[a]=i.length-2,r[a+1]=i.length-1):this.isSeamVertex(a+2,i,r)&&(this.isEndVertex(a,i,r)&&this.isEndVertex(a+1,i,r)?(i.push(o.copy(i[r[a+2]])),n.push(o.normalize(i[r[a+2]])),h.push(1,h[r[a+2]*2+1]),r[a+2]=i.length-1):this.isEndVertex(a,i,r)?(i.push(o.copy(i[r[a+1]])),n.push(o.normalize(i[r[a+1]])),h.push(1,h[r[a+1]*2+1]),i.push(o.copy(i[r[a+2]])),n.push(o.normalize(i[r[a+2]])),h.push(1,h[r[a+2]*2+1]),r[a+1]=i.length-2,r[a+2]=i.length-1):this.isEndVertex(a+1,i,r)&&(i.push(o.copy(i[r[a]])),n.push(o.normalize(i[r[a]])),h.push(1,h[r[a]*2+1]),i.push(o.copy(i[r[a+2]])),n.push(o.normalize(i[r[a+2]])),h.push(1,h[r[a+2]*2+1]),r[a]=i.length-2,r[a+2]=i.length-1));this.setVertices(i),this.setNormals(n),this.setTextureCoordinates(h),this.setIndices(r),this.createDefaultVertexColors()}isEndVertex(t,e,i){return e[i[t]].x>0}isSeamVertex(t,e,i){return e[i[t]].x==0&&e[i[t]].z<=0}createCentroids(t,e,i,r){const n=[],h=o.add(t[e],t[i]);h.divideScalar(2),h.normalize(),n.push(h);const u=o.add(t[i],t[r]);u.divideScalar(2),u.normalize(),n.push(u);const l=o.add(t[r],t[e]);return l.divideScalar(2),l.normalize(),n.push(l),n}subdivide(t,e,i,r,n,h){const u=[];return u.push(t,r,h),u.push(e,n,r),u.push(i,h,n),u.push(r,n,h),u}mergeSharedVertices(t,e){const i=[],r=[];e.forEach(n=>{r.push(n)});for(let n=0;n<t.length;n++){let h=!1;for(let u=0;u<i.length;u++)if(t[n].equals(i[u])){for(let l=0;l<e.length;l++)e[l]==n&&(r[l]=u);h=!0}if(!h){i.push(t[n]);for(let u=0;u<e.length;u++)e[u]==n&&(r[u]=i.length-1)}}return[i,r]}}class at extends S{constructor(t=1,e=1){super(),this.width=t,this.height=e,this.createVertices(this.width,this.height),this.createNormals(),this.createTextureCoords(),this.createIndices(),this.createDefaultVertexColors()}createVertices(t,e){const i=[];i.push(-t/2,-e/2,0),i.push(t/2,-e/2,0),i.push(t/2,e/2,0),i.push(-t/2,e/2,0),this.setVertices(i)}createNormals(){const t=[];t.push(0,0,-1),t.push(0,0,-1),t.push(0,0,-1),t.push(0,0,-1),this.setNormals(t)}createIndices(){const t=[];t.push(0,2,1),t.push(2,0,3),this.setIndices(t)}createTextureCoords(){const t=[];t.push(1,1),t.push(0,1),t.push(0,0),t.push(1,0),this.setTextureCoordinates(t)}}var L=(s=>(s[s.POINT=0]="POINT",s[s.DIRECTIONAL=1]="DIRECTIONAL",s))(L||{});class K extends D{constructor(t=0,e=new g,i=new g,r=new g){super(),this.type=t,this.ambientIntensity=e,this.diffuseIntensity=i,this.specularIntensity=r}getType(){return this.type}setLights(t){t.addLight(this),super.setLights(t)}}class ot extends K{constructor(t=new g(.5,.5,.5)){super(L.POINT,t,new g(0,0,0),new g(0,0,0))}}class ut extends K{constructor(t=new g(.5,.5,.5)){super(L.DIRECTIONAL,new g(0,0,0),t,t)}}var lt=`#version 300 es

precision mediump float;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

in vec3 position;

void main() 
{
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);
}`,mt=`#version 300 es

precision mediump float;

uniform vec4 color;

out vec4 fragColor;

void main() 
{
    fragColor = color;
}`;const T=class extends v{constructor(){super(),this.color=new R(1,1,1,1),this.wireframeBuffers=new Map,T.shader.initialize(this.gl),this.positionAttribute=T.shader.getAttribute(this.gl,"position"),this.modelViewUniform=T.shader.getUniform(this.gl,"modelViewMatrix"),this.projectionUniform=T.shader.getUniform(this.gl,"projectionMatrix"),this.colorUniform=T.shader.getUniform(this.gl,"color")}draw(s,t,e,i){!this.visible||s.triangleCount==0||(this.initialize(),this.gl.useProgram(T.shader.getProgram()),this.gl.uniformMatrix4fv(this.modelViewUniform,!1,B.multiply(t.getWorldMatrix(),e.getViewMatrix()).mat),this.gl.uniformMatrix4fv(this.projectionUniform,!1,e.getProjectionMatrix().mat),this.gl.uniform4f(this.colorUniform,this.color.r,this.color.g,this.color.b,this.color.a),this.gl.enableVertexAttribArray(this.positionAttribute),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s.positionBuffer),this.gl.vertexAttribPointer(this.positionAttribute,3,this.gl.FLOAT,!1,0,0),(!this.wireframeBuffers.get(s)||s.positionBufferDirty)&&this.updateWireframeBuffer(s),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.wireframeBuffers.get(s)),this.gl.drawElements(this.gl.LINES,s.triangleCount*6,this.gl.UNSIGNED_SHORT,0))}updateWireframeBuffer(s){let t;t=this.wireframeBuffers.get(s),t||(t=this.gl.createBuffer(),t&&this.wireframeBuffers.set(s,t));const e=new Uint16Array(s.triangleCount*3);this.gl.bindBuffer(this.gl.COPY_READ_BUFFER,s.indexBuffer),this.gl.getBufferSubData(this.gl.COPY_READ_BUFFER,0,e);const i=[...e],r=[];for(let n=0;n<s.triangleCount;n++)r.push(i[n*3]),r.push(i[n*3+1]),r.push(i[n*3+1]),r.push(i[n*3+2]),r.push(i[n*3+2]),r.push(i[n*3]);this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t),this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(r),this.gl.DYNAMIC_DRAW)}};let G=T;G.shader=new k(lt,mt);var ct=`#version 300 es

precision mediump float;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

in vec3 position;
in vec2 texCoord;

out vec2 uv;

void main() 
{
    uv = texCoord.xy;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);
}`,ft=`#version 300 es

precision mediump float;

uniform vec3 color;
uniform int useTexture;
uniform sampler2D textureImage;

in vec2 uv;

out vec4 fragColor;

void main() 
{
    fragColor = vec4(color, 1);

    if(useTexture != 0)
    {
        fragColor *= texture(textureImage, uv);
    }
}`;const E=class extends v{constructor(){super(),this.texture=null,this.color=new g(1,1,1),E.shader.initialize(this.gl),this.colorUniform=E.shader.getUniform(this.gl,"color"),this.textureUniform=E.shader.getUniform(this.gl,"textureImage"),this.useTextureUniform=E.shader.getUniform(this.gl,"useTexture"),this.modelViewUniform=E.shader.getUniform(this.gl,"modelViewMatrix"),this.projectionUniform=E.shader.getUniform(this.gl,"projectionMatrix"),this.positionAttribute=E.shader.getAttribute(this.gl,"position"),this.texCoordAttribute=E.shader.getAttribute(this.gl,"texCoord")}draw(s,t,e,i){!this.visible||s.triangleCount==0||(this.initialize(),this.gl.useProgram(E.shader.getProgram()),this.gl.uniformMatrix4fv(this.modelViewUniform,!1,B.multiply(t.getWorldMatrix(),e.getViewMatrix()).mat),this.gl.uniformMatrix4fv(this.projectionUniform,!1,e.getProjectionMatrix().mat),this.gl.uniform3f(this.colorUniform,this.color.r,this.color.g,this.color.b),this.gl.enableVertexAttribArray(this.positionAttribute),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s.positionBuffer),this.gl.vertexAttribPointer(this.positionAttribute,3,this.gl.FLOAT,!1,0,0),this.texture?(this.gl.uniform1i(this.useTextureUniform,1),this.gl.activeTexture(this.gl.TEXTURE0+this.texture.id),this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture.texture),this.gl.uniform1i(this.textureUniform,this.texture.id),this.gl.enableVertexAttribArray(this.texCoordAttribute),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s.texCoordBuffer),this.gl.vertexAttribPointer(this.texCoordAttribute,2,this.gl.FLOAT,!1,0,0)):this.gl.uniform1i(this.useTextureUniform,0),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,s.indexBuffer),this.gl.drawElements(this.gl.TRIANGLES,s.triangleCount*3,this.gl.UNSIGNED_SHORT,0))}};let _=E;_.shader=new k(ct,ft);var Z=(s=>(s[s.BOX=0]="BOX",s[s.SPHERE=1]="SPHERE",s[s.NONE=2]="NONE",s))(Z||{});class dt extends v{constructor(t=0,e=new R(1,1,1,1)){super(),this.color=e,this.mode=t,this.sphere=new P(1,2),this.box=new X(1,1,1);const i=new G;i.color.copy(this.color),this.sphere.material=i,this.box.material=i}draw(t,e,i,r){if(this.mode==0){const n=o.add(t.boundingBox.min,t.boundingBox.max);n.multiplyScalar(.5),this.box.position.copy(n),this.box.scale.set(t.boundingBox.max.x-t.boundingBox.min.x,t.boundingBox.max.y-t.boundingBox.min.y,t.boundingBox.max.z-t.boundingBox.min.z),this.box.computeWorldTransform(t),this.box.draw(t,i,r)}else this.mode==1&&(this.sphere.position.copy(t.boundingSphere.center),this.sphere.scale.set(t.boundingSphere.radius,t.boundingSphere.radius,t.boundingSphere.radius),this.sphere.computeWorldTransform(t),this.sphere.draw(t,i,r))}}class gt{constructor(t){this.tokens=[],this.line=0,this.token=0;const e=t.split(`
`);for(let i=0;i<e.length;i++)this.tokens.push(e[i].trim().split(/\s+/));for(let i=0;i<this.tokens.length;i++)this.tokens[i].length==1&&this.tokens[i][0]==""&&(this.tokens.splice(i,1),i--)}peek(){return this.tokens[this.line][this.token]}expect(t){return this.peek()==t?(this.readToken(),!0):!1}consumeLine(){this.line++,this.token=0}done(){return this.line>=this.tokens.length}readToken(){const t=this.tokens[this.line][this.token];return this.token++,this.token>=this.tokens[this.line].length&&(this.line++,this.token=0),t}readNumber(){return Number(this.readToken())}readLine(){const t=[];for(let e=this.token;e<this.tokens[this.line].length;e++)t.push(this.tokens[this.line][e]);return this.line++,this.token=0,t}}class N{static load(t,e=null,i=null){return e||(e=new S),fetch(t).then(r=>{if(!r.ok)throw new Error;return r.blob()}).then(r=>{r.text().then(n=>{N.parse(n,e),i&&i(e)})}).catch(()=>{console.error("Unable to download file: "+t)}),e}static parse(t,e){const i=new gt(t),r=[],n=[],h=[],u=[];for(;!i.done();){const l=i.readToken();l=="v"?this.parseVertex(i.readLine(),r,n):l=="vn"?this.parseNormal(i.readLine(),h):l=="f"?this.parseFace(i.readLine(),u):i.consumeLine()}e.setVertices(r),e.setColors(n),e.setNormals(h),e.setIndices(u),n.length==0&&e.createDefaultVertexColors()}static parseVertex(t,e,i){e.push(Number(t[0])),e.push(Number(t[1])),e.push(Number(t[2])),t.length==6&&(i.push(Number(t[3])),i.push(Number(t[4])),i.push(Number(t[5])),i.push(1))}static parseNormal(t,e){e.push(Number(t[0])),e.push(Number(t[1])),e.push(Number(t[2]))}static parseFace(t,e){for(let i=0;i<3;i++){const r=t[i].split("/");e.push(Number(r[0])-1)}}}class pt extends I{constructor(){super(),this.ground=new at(1e3,1e3),this.sky=new P(500),this.line=new X(.01,.01,100),this.marker=new P(.05),this.testMesh=N.load("./assets/bunny.obj"),this.testMeshBounds=new ht(this.testMesh)}createScene(){this.camera=new it(3,60,1920/1080,.1,1e3);const t=new ot(new g(.5,.5,.5));this.scene.add(t);const e=new ut(new g(.6,.6,.6));e.position.set(10,0,0),this.scene.add(e);const i=new F;i.ambientColor.set(.425,.9,.555),this.ground.material=i,this.ground.position.set(0,-1,0),this.ground.rotation.setEulerAngles(0,Math.PI/2,0),this.scene.add(this.ground);const r=new _;r.side=H.BACK,r.color.set(.529,.807,.921),this.sky.material=r,this.scene.add(this.sky);const n=new F;n.ambientColor.set(0,0,1),n.specularColor.set(1,1,1),this.testMesh.material=n,this.scene.add(this.testMesh),this.testMeshBounds.material=new dt(Z.BOX),this.testMesh.add(this.testMeshBounds);const h=new _;h.color.set(1,0,1),this.line.material=h,this.line.visible=!1,this.scene.add(this.line);const u=new F;u.ambientColor.set(1,0,0),u.diffuseColor.set(1,0,0),this.marker.material=u,this.marker.visible=!1,this.scene.add(this.marker)}update(t){}onMouseDown(t){const e=this.renderer.getNormalizedDeviceCoordinates(t.x,t.y),i=new st;i.setPickRay(e,this.camera),this.line.visible=!0,this.line.position.copy(i.ray.origin),this.line.lookAt(o.add(i.ray.origin,i.ray.direction)),this.line.translateZ(this.line.depth/-2-.5),this.marker.visible=!1;const r=i.intersectsMesh(this.testMesh);if(r){this.marker.position.copy(r),this.marker.visible=!0;return}const n=new et(this.ground.position,o.UP),h=i.intersectsPlane(n);if(h){this.marker.position.copy(h),this.marker.visible=!0;return}}}const xt=new pt;xt.start();
